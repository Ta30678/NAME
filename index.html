<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ETABS 梁自動編號工具</title>
    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
    <script src="./svg-pan-zoom.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', 'Microsoft JhengHei', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #2c3e50;
            color: #ecf0f1;
        }
        h1 {
            color: #e67e22;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        #container {
            width: 90%;
            max-width: 1200px;
            background: #34495e;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            border: 1px solid #4a6278;
        }
        .controls {
            margin-bottom: 20px;
            padding: 20px;
            border: 1px dashed #4a6278;
            border-radius: 5px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        input[type="file"] {
            border: 1px solid #7f8c8d;
            padding: 8px;
            border-radius: 4px;
            background-color: #2c3e50;
            color: #ecf0f1;
        }
        button {
            padding: 10px 20px;
            color: white;
            background-color: #e67e22;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.2);
        }
        button:hover {
            background-color: #d35400;
        }
        /* No need for separate button classes, all buttons are orange now */
        .btn-process, .btn-export {}
        .btn-process:hover, .btn-export:hover {}
        button:disabled {
            background-color: #7f8c8d;
            cursor: not-allowed;
            color: #bdc3c7;
        }
        #output {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        #drawing, #results-table {
            flex: 1;
            min-width: 300px;
            border: 1px solid #4a6278;
            padding: 10px;
            border-radius: 5px;
            /* max-height: 70vh; */ /* Removed for natural scrolling */
            /* overflow: auto; */   /* Removed for natural scrolling */
            background-color: #2c3e50;
        }
        #drawing-svg {
            width: 100%;
            height: 400px;
            border: 1px solid #4a6278;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid #4a6278;
            padding: 8px;
            text-align: left;
            word-break: break-all;
        }
        th {
            background-color: #4a6278;
        }
        .error {
            color: #e74c3c; /* A nicer red */
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="container">
        <h1>ETABS 梁自動編號工具 (v30 - 最終架構修正)</h1>
        <div class="controls">
            <label for="e2kFile">請選擇 ETABS .e2k 檔案:</label>
            <input type="file" id="e2kFile" accept=".e2k">
            <button class="btn-process" onclick="processE2k()">開始編號</button>
            <button class="btn-export" id="exportBtn" onclick="exportToExcel()" disabled>匯出成 Excel</button>
            <label for="floorSelect">選擇樓層:</label>
            <select id="floorSelect" onchange="redrawCurrentData()"></select>
        </div>
        <div id="status"></div>
        <div id="output">
            <div id="drawing">
                <h3>結構平面圖 (所有樓層合併)</h3>
                <svg id="drawing-svg"></svg>
            </div>
            <div id="results-table">
                <h3>編號對照表 (所有樓層)</h3>
                <table id="beam-table">
                    <thead>
                        <tr><th>樓層</th><th>原始 ETABS 編號</th><th>新編號</th><th>Property</th></tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
    </div>
    <script>
        let processedBeamsData = [];
        let storyOrderInfo = {};
        let allBeamsData = []; // Store all beams with joint coords
        let allGrids = {}; // Store parsed grids
        let panZoomInstance = null; // To hold the pan/zoom instance
        const TOLERANCE = 0.1;

        function parseGrids(content) {
            const grids = { x: [], y: [] };
            const gridTableSection = content.match(/TABLE:\s+"GRID DEFINITIONS - LINES"([\s\S]*?)(?=TABLE:|$)/);
            if (gridTableSection) {
                let currentGrid = {};
                const lines = gridTableSection[1].trim().split('\n');
                lines.forEach(line => {
                    const trimmedLine = line.trim();
                    if (trimmedLine === "") {
                        if (currentGrid.name && currentGrid.type && currentGrid.ordinate !== undefined) {
                            if (currentGrid.type.toUpperCase() === 'X') grids.x.push(currentGrid); else if (currentGrid.type.toUpperCase() === 'Y') grids.y.push(currentGrid);
                        }
                        currentGrid = {};
                    } else {
                        const match = trimmedLine.match(/(\S+)\s*=\s*"?([^"]*)"?/);
                        if (match) { const [, key, value] = match; if (key === 'GridID') currentGrid.name = value; if (key === 'GridType') currentGrid.type = value; if (key === 'Ordinate') currentGrid.ordinate = parseFloat(value); }
                    }
                });
                if (currentGrid.name) { if (currentGrid.type.toUpperCase() === 'X') grids.x.push(currentGrid); else if (currentGrid.type.toUpperCase() === 'Y') grids.y.push(currentGrid); }
            }
            if (grids.x.length === 0 && grids.y.length === 0) {
                const gridDollarSection = content.match(/\$ GRIDS([\s\S]*?)(?=\$|$)/);
                if (gridDollarSection) {
                    const lines = gridDollarSection[1].trim().split('\n');
                    lines.forEach(line => {
                        const match = line.match(/LABEL\s+"([^"]+)"\s+DIR\s+"(X|Y)"\s+COORD\s+([-\d\.]+)/i);
                        if (match) { const [, name, type, ordinate] = match; const gridInfo = { name, type, ordinate: parseFloat(ordinate) }; if (type.toUpperCase() === 'X') grids.x.push(gridInfo); else if (type.toUpperCase() === 'Y') grids.y.push(gridInfo); }
                    });
                }
            }
            if (grids.x.length === 0 && grids.y.length === 0) { throw new Error("找不到格線定義。"); }
            grids.x = [...new Map(grids.x.map(item => [item.name, item])).values()].sort((a, b) => a.ordinate - b.ordinate);
            grids.y = [...new Map(grids.y.map(item => [item.name, item])).values()].sort((a, b) => a.ordinate - b.ordinate);
            return grids;
        }

        function parseJoints(content) {
            const joints = {};
            const jointTableSection = content.match(/TABLE:\s+"JOINT COORDINATES"([\s\S]*?)(?=TABLE:|$)/);
            if (jointTableSection) {
                const lines = jointTableSection[1].trim().split('\n');
                lines.forEach(line => { if (line.trim().startsWith('JOINT')) return; const match = line.trim().match(/^"([^"]+)"\s+([-\d\.]+)\s+([-\d\.]+)/); if (match) { joints[match[1]] = { x: parseFloat(match[2]), y: parseFloat(match[3]) }; } });
            }
            if (Object.keys(joints).length === 0) {
                const lines = content.split('\n');
                lines.forEach(line => { const match = line.trim().match(/^POINT\s+"([^"]+)"\s+([-\d\.]+)\s+([-\d\.]+)/); if (match) { joints[match[1]] = { x: parseFloat(match[2]), y: parseFloat(match[3]) }; } });
            }
            if (Object.keys(joints).length === 0) {
                const jointDollarSection = content.match(/\$ JOINTS([\s\S]*?)(?=\$|$)/s);
                if (jointDollarSection) {
                    const lines = jointDollarSection[1].trim().split('\n');
                    lines.forEach(line => { const match = line.match(/NAME\s*=\s*(\S+)\s*X\s*=\s*([-\d\.]+)\s*Y\s*=\s*([-\d\.]+)/); if (match) { joints[match[1]] = { x: parseFloat(match[2]), y: parseFloat(match[3]) }; } });
                }
            }
            if (Object.keys(joints).length === 0) { throw new Error("找不到節點座標定義。"); }
            return joints;
        }

        function parseFrames(content, story) {
            const frames = [];
            const isBeamProp = (propName) => {
                if (!propName) return false;
                const p = propName.toUpperCase();
                return (p.startsWith('B') && !p.startsWith('SB')) || p.startsWith('FB') || p.startsWith('WB') || p.startsWith('FWB') || /^\d+[B]/.test(p);
            };
            const frameTableSection = content.match(/TABLE:\s+"CONNECTIVITY - FRAME"([\s\S]*?)(?=TABLE:|$)/);
            const frameAssignSection = content.match(/TABLE:\s+"FRAME ASSIGNS - SECTION"([\s\S]*?)(?=TABLE:|$)/);
            if (frameTableSection && frameAssignSection) {
                const connectivityLines = frameTableSection[1].trim().split('\n'); const assignLines = frameAssignSection[1].trim().split('\n'); const frameProperties = new Map();
                assignLines.forEach(line => { const match = line.trim().match(/^"([^"]+)"\s+"([^"]+)"\s+"([^"]+)"/); if (match && match[2] === story) { frameProperties.set(match[1], match[3]); } });
                connectivityLines.forEach(line => { const match = line.trim().match(/^"([^"]+)"\s+"([^"]+)"\s+"([^"]+)"/); if (match) { const [, name, joint1, joint2] = match; const propName = frameProperties.get(name); if (isBeamProp(propName)) { frames.push({ name, prop: propName, joint1, joint2, story }); } } });
            }
            if (frames.length === 0) {
                const lineConnectivitySection = content.match(/\$ LINE CONNECTIVITIES([\s\S]*?)(?=\$|$)/i); const lineAssignsSection = content.match(/\$ LINE ASSIGNS([\s\S]*?)(?=\$|$)/i);
                if (lineConnectivitySection && lineAssignsSection) {
                    const connectLines = lineConnectivitySection[1].trim().split('\n'); const assignLines = lineAssignsSection[1].trim().split('\n'); const beamAssigns = new Map();
                    assignLines.forEach(line => { const assignMatch = line.match(new RegExp(`LINEASSIGN\\s+"([^"]+)"\\s+"${story}"\\s+SECTION\\s+"([^"]+)"`, 'i')); if (assignMatch) { const [, name, propName] = assignMatch; if (isBeamProp(propName)) { beamAssigns.set(name, propName); } } });
                    connectLines.forEach(line => { const connMatch = line.match(/LINE\s+"([^"]+)"\s+BEAM\s+"([^"]+)"\s+"([^"]+)"/i); if (connMatch) { const [, name, joint1, joint2] = connMatch; if (beamAssigns.has(name)) { frames.push({ name, prop: beamAssigns.get(name), joint1, joint2, story }); } } });
                }
            }
            return frames;
        }

        function findClosestGrid(coordinate, grids) {
            if (!grids || grids.length === 0) return null;
            return grids.reduce((closest, current) => {
                const closestDiff = Math.abs(coordinate - closest.ordinate);
                const currentDiff = Math.abs(coordinate - current.ordinate);
                return currentDiff < closestDiff ? current : closest;
            });
        }
        
        function generateLabelsForStory(beamsInStory, joints, grids) {
            const labelComponentMap = new Map();
            const beamsWithCoords = beamsInStory.map(b => {
                const j1 = joints[b.joint1]; const j2 = joints[b.joint2]; if (!j1 || !j2) return null;
                return { ...b, j1, j2,
                    centerX: (j1.x + j2.x) / 2, centerY: (j1.y + j2.y) / 2,
                    minX: Math.min(j1.x, j2.x), maxX: Math.max(j1.x, j2.x),
                    minY: Math.min(j1.y, j2.y), maxY: Math.max(j1.y, j2.y),
                    isHorizontal: Math.abs(j1.y - j2.y) < TOLERANCE, isVertical: Math.abs(j1.x - j2.x) < TOLERANCE
                };
            }).filter(Boolean);

            const yGridNameToNum = new Map(grids.y.map((grid, index) => [grid.name, index + 1]));

            // --- 1. 處理水平梁 ---
            const horizontalBeams = beamsWithCoords.filter(b => b.isHorizontal);
            const onGridHorizontal = []; const offGridHorizontal = [];
            horizontalBeams.forEach(beam => {
                let onGrid = false;
                for (const grid of grids.y) { if (Math.abs(beam.centerY - grid.ordinate) < TOLERANCE) { onGrid = true; break; } }
                if (onGrid) { onGridHorizontal.push(beam); } else { offGridHorizontal.push(beam); }
            });

            onGridHorizontal.forEach(beam => {
                const onGrid = findClosestGrid(beam.centerY, grids.y);
                const endGrid = findClosestGrid(beam.maxX, grids.x);
                if (onGrid && endGrid) {
                    const serial = parseInt(endGrid.name, 10);
                    if(!isNaN(serial)) {
                        labelComponentMap.set(beam.name, { isVertical: false, primaryGridName: onGrid.name, subGridMarker: '', serial: serial });
                    }
                }
            });

            const yBayGroups = new Map();
            offGridHorizontal.forEach(beam => {
                let prevGrid = null, nextGrid = null;
                for (let i = 0; i < grids.y.length - 1; i++) {
                    if (beam.centerY > grids.y[i].ordinate && beam.centerY < grids.y[i+1].ordinate) {
                        prevGrid = grids.y[i]; nextGrid = grids.y[i+1]; break;
                    }
                }
                if (prevGrid && nextGrid) { const bayKey = `${prevGrid.name}_${nextGrid.name}`; if (!yBayGroups.has(bayKey)) yBayGroups.set(bayKey, []); yBayGroups.get(bayKey).push(beam); }
            });
            yBayGroups.forEach((beamsInBay, bayKey) => {
                const prevYGridName = bayKey.split('_')[0];
                const uniqueYCoords = [...new Set(beamsInBay.map(b => b.centerY.toFixed(2)))].sort((a,b) => parseFloat(a) - parseFloat(b));
                const yCoordToRank = new Map(uniqueYCoords.map((coord, index) => [coord, index]));
                beamsInBay.forEach(beam => {
                    const endGrid = findClosestGrid(beam.maxX, grids.x);
                    if (endGrid) {
                        const rank = yCoordToRank.get(beam.centerY.toFixed(2));
                        const serial = parseInt(endGrid.name, 10);
                        if (!isNaN(serial) && rank !== undefined) {
                            const subGridMarker = "'".repeat(rank + 1);
                            labelComponentMap.set(beam.name, { isVertical: false, primaryGridName: prevYGridName, subGridMarker: subGridMarker, serial: serial });
                        }
                    }
                });
            });

            // --- 2. 處理垂直梁 ---
            const verticalBeams = beamsWithCoords.filter(b => b.isVertical);
            const onGridVertical = []; const offGridVertical = [];
            verticalBeams.forEach(beam => {
                let onGrid = false;
                for (const grid of grids.x) { if (Math.abs(beam.centerX - grid.ordinate) < TOLERANCE) { onGrid = true; break; } }
                if (onGrid) { onGridVertical.push(beam); } else { offGridVertical.push(beam); }
            });

            onGridVertical.forEach(beam => {
                const onGrid = findClosestGrid(beam.centerX, grids.x);
                const endGrid = findClosestGrid(beam.maxY, grids.y);
                if (onGrid && endGrid) {
                    const endYGridNum = yGridNameToNum.get(endGrid.name);
                    if (endYGridNum !== undefined) {
                        const serial = endYGridNum - 1;
                        labelComponentMap.set(beam.name, { isVertical: true, primaryGridName: onGrid.name, subGridMarker: '', serial: serial });
                    }
                }
            });

            const xBayGroups = new Map();
            offGridVertical.forEach(beam => {
                let prevGrid = null, nextGrid = null;
                for (let i = 0; i < grids.x.length - 1; i++) { if (beam.centerX > grids.x[i].ordinate && beam.centerX < grids.x[i+1].ordinate) { prevGrid = grids.x[i]; nextGrid = grids.x[i+1]; break; } }
                if (prevGrid && nextGrid) { const bayKey = `${prevGrid.name}_${nextGrid.name}`; if (!xBayGroups.has(bayKey)) xBayGroups.set(bayKey, []); xBayGroups.get(bayKey).push(beam); }
            });
            xBayGroups.forEach((group, bayKey) => {
                const prevXGridName = bayKey.split('_')[0];
                const uniqueXCoords = [...new Set(group.map(b => b.centerX.toFixed(2)))].sort((a, b) => parseFloat(a) - parseFloat(b));
                const xCoordToRank = new Map(uniqueXCoords.map((coord, index) => [coord, index]));
                group.forEach(beam => {
                    const endGrid = findClosestGrid(beam.maxY, grids.y);
                    if (endGrid) {
                        const rank = xCoordToRank.get(beam.centerX.toFixed(2));
                        const endYGridNum = yGridNameToNum.get(endGrid.name);
                        if (endYGridNum !== undefined && rank !== undefined) {
                            const serial = endYGridNum - 1;
                            const subGridMarker = "'".repeat(rank + 1);
                            labelComponentMap.set(beam.name, { isVertical: true, primaryGridName: prevXGridName, subGridMarker: subGridMarker, serial: serial });
                        }
                    }
                });
            });
            return labelComponentMap;
        }

        function applySpecialPrefixRules(allBeams) {
            const processPrefix = (prefix) => {
                const targetBeams = allBeams.filter(b => b.prop && b.prop.toUpperCase().startsWith(prefix)); if (targetBeams.length === 0) return null;
                const uniqueProps = [...new Set(targetBeams.map(b => b.prop))];
                const propRanks = uniqueProps.map(prop => { const match = prop.match(/(\d+)[xX](\d+)/); if (match) { return { propName: prop, area: parseInt(match[1], 10) * parseInt(match[2], 10) }; } return { propName: prop, area: Infinity }; }).sort((a, b) => a.area - b.area);
                const propToLabelMap = new Map(); propRanks.forEach((propInfo, index) => { propToLabelMap.set(propInfo.propName, `${prefix}${index + 1}`); }); return propToLabelMap;
            };
            const wbLabelMap = processPrefix('WB'); const fwbLabelMap = processPrefix('FWB');
            return allBeams.map(beam => {
                if (wbLabelMap && wbLabelMap.has(beam.prop)) { return { ...beam, newLabel: wbLabelMap.get(beam.prop) }; }
                if (fwbLabelMap && fwbLabelMap.has(beam.prop)) { return { ...beam, newLabel: fwbLabelMap.get(beam.prop) }; }
                return beam;
            });
        }

        function displayResults(labeledBeams, allBeams, svg, tableBody, grids, story) {
            // The table is now updated in redrawCurrentData or the main process function
            const allCoords = allBeams.flatMap(b => [b.j1, b.j2]).filter(Boolean); if (allCoords.length === 0) { svg.innerHTML = '<text x="50%" y="50%" fill="#ecf0f1" text-anchor="middle">無資料</text>'; return; }
            const minX = Math.min(...allCoords.map(p => p.x)), maxX = Math.max(...allCoords.map(p => p.x)); const minY = Math.min(...allCoords.map(p => p.y)), maxY = Math.max(...allCoords.map(p => p.y));
            const padding = 50, svgWidth = svg.clientWidth, svgHeight = svg.clientHeight; const contentWidth = maxX - minX, contentHeight = maxY - minY; let scale = Math.min((svgWidth - 2 * padding) / (contentWidth||1), (svgHeight - 2 * padding) / (contentHeight||1)) * 0.9;
            if (!isFinite(scale) || scale === 0) scale = 1;
            const transformX = (x) => padding + (x - minX) * scale; const transformY = (y) => svgHeight - padding - (y - minY) * scale;
            svg.innerHTML = '';

            // Draw grid lines
            if (grids && grids.x && grids.y) {
                const gridGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                gridGroup.setAttribute('id', 'grid-lines');

                const textPadding = 5;
                const labelFontSize = 10;

                // Draw X grids (vertical lines)
                grids.x.forEach(grid => {
                    const x = transformX(grid.ordinate);
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', x);
                    line.setAttribute('y1', transformY(minY) - padding / 2); // Extend slightly
                    line.setAttribute('x2', x);
                    line.setAttribute('y2', transformY(maxY) + padding / 2); // Extend slightly
                    line.setAttribute('stroke', '#4a6278');
                    line.setAttribute('stroke-width', '0.5');
                    gridGroup.appendChild(line);

                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', x);
                    text.setAttribute('y', transformY(minY) - textPadding);
                    text.setAttribute('fill', '#bdc3c7');
                    text.setAttribute('font-size', labelFontSize);
                    text.setAttribute('text-anchor', 'middle');
                    text.textContent = grid.name;
                    gridGroup.appendChild(text);
                });

                // Draw Y grids (horizontal lines)
                grids.y.forEach(grid => {
                    const y = transformY(grid.ordinate);
                    const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                    line.setAttribute('x1', transformX(minX) - padding/2); // Extend slightly
                    line.setAttribute('y1', y);
                    line.setAttribute('x2', transformX(maxX) + padding/2); // Extend slightly
                    line.setAttribute('y2', y);
                    line.setAttribute('stroke', '#4a6278');
                    line.setAttribute('stroke-width', '0.5');
                    gridGroup.appendChild(line);

                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', transformX(minX) - textPadding);
                    text.setAttribute('y', y);
                    text.setAttribute('fill', '#bdc3c7');
                    text.setAttribute('font-size', labelFontSize);
                    text.setAttribute('text-anchor', 'end');
                    text.setAttribute('alignment-baseline', 'middle');
                    text.textContent = grid.name;
                    gridGroup.appendChild(text);
                });
                svg.appendChild(gridGroup);
            }

            const allDrawableBeams = allBeams.filter(b => b.j1 && b.j2);
            const labeledBeamsMap = new Map(labeledBeams.map(b => [b.name, b]));

            allDrawableBeams.forEach(beam => {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', transformX(beam.j1.x));
                line.setAttribute('y1', transformY(beam.j1.y));
                line.setAttribute('x2', transformX(beam.j2.x));
                line.setAttribute('y2', transformY(beam.j2.y));

                const labeledInfo = labeledBeamsMap.get(beam.name);

                if (labeledInfo) {
                    const isSpecial = labeledInfo.newLabel && (labeledInfo.newLabel.startsWith('WB') || labeledInfo.newLabel.startsWith('FWB'));
                    line.setAttribute('stroke', isSpecial ? '#f39c12' : '#e67e22');
                    line.setAttribute('stroke-width', '3');
                    svg.appendChild(line);

                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    const textX = (transformX(beam.j1.x) + transformX(beam.j2.x)) / 2;
                    const textY = (transformY(beam.j1.y) + transformY(beam.j2.y)) / 2 - 5;
                    text.setAttribute('x', textX);
                    text.setAttribute('y', textY);
                    text.setAttribute('fill', '#ecf0f1');
                    text.setAttribute('font-size', '10');
                    text.setAttribute('text-anchor', 'middle');
                    text.textContent = labeledInfo.newLabel;
                    svg.appendChild(text);
                } else {
                    line.setAttribute('stroke', '#7f8c8d');
                    line.setAttribute('stroke-width', '1');
                    svg.appendChild(line);
                }
            });

            // Init Pan/Zoom on the next animation frame to ensure SVG is rendered
            requestAnimationFrame(() => {
                panZoomInstance = svgPanZoom(svg, {
                    zoomEnabled: true,
                    controlIconsEnabled: true,
                    fit: true,
                    center: true,
                    minZoom: 0.1,
                    maxZoom: 20
                });
            });
        }
        
        function redrawCurrentData() {
            const floorSelect = document.getElementById('floorSelect');
            const selectedStory = floorSelect.value;
            const svg = document.getElementById('drawing-svg');
            const tableBody = document.querySelector("#beam-table tbody");
            const drawingTitle = document.querySelector("#drawing h3");
            const tableTitle = document.querySelector("#results-table h3");

            let beamsToLabel = processedBeamsData;
            let backgroundBeams = allBeamsData;
            let tableRows = processedBeamsData;

            if (selectedStory !== 'all') {
                beamsToLabel = processedBeamsData.filter(b => b.story === selectedStory);
                backgroundBeams = allBeamsData.filter(b => b.story === selectedStory);
                tableRows = processedBeamsData.filter(b => b.story === selectedStory);
                drawingTitle.textContent = `結構平面圖 (${selectedStory})`;
                tableTitle.textContent = `編號對照表 (${selectedStory})`;
            } else {
                drawingTitle.textContent = `結構平面圖 (所有樓層合併)`;
                tableTitle.textContent = `編號對照表 (所有樓層)`;
            }

            if (panZoomInstance) {
                panZoomInstance.destroy();
                panZoomInstance = null;
            }

            displayResults(beamsToLabel, backgroundBeams, svg, tableBody, allGrids, selectedStory);

            // Update table content separately
            tableBody.innerHTML = '';
            tableRows.forEach(beam => {
                const row = tableBody.insertRow();
                row.insertCell(0).textContent = beam.story;
                row.insertCell(1).textContent = beam.name;
                row.insertCell(2).textContent = beam.newLabel;
                row.insertCell(3).textContent = beam.prop;
            });
        }

        function exportToExcel() {
            if (processedBeamsData.length === 0) { alert("沒有資料可以匯出。"); return; }
            const dataForExport = [...processedBeamsData]; if (Object.keys(storyOrderInfo).length > 0) { dataForExport.sort((a, b) => storyOrderInfo[a.story] - storyOrderInfo[b.story]); }
            const worksheetData = dataForExport.map(beam => ({ '樓層': beam.story, '原始ETABS編號': beam.name, '新編號': beam.newLabel, 'Property': beam.prop }));
            const worksheet = XLSX.utils.json_to_sheet(worksheetData); const workbook = XLSX.utils.book_new(); XLSX.utils.book_append_sheet(workbook, worksheet, "梁編號對照表"); XLSX.writeFile(workbook, "ETABS_Beam_Numbering.xlsx");
        }
        
        async function processE2k() {
            const fileInput = document.getElementById('e2kFile'); const statusDiv = document.getElementById('status'); const svg = document.getElementById('drawing-svg'); const tableBody = document.querySelector("#beam-table tbody"); const exportBtn = document.getElementById('exportBtn');
            statusDiv.innerHTML = ''; svg.innerHTML = ''; tableBody.innerHTML = ''; processedBeamsData = []; storyOrderInfo = {}; exportBtn.disabled = true;
            if (fileInput.files.length === 0) { statusDiv.innerHTML = '<p class="error">錯誤：請先選擇一個 .e2k 檔案。</p>'; return; }
            const file = fileInput.files[0]; statusDiv.innerHTML = `<p>正在讀取檔案 "${file.name}"...</p>`; let fileContent; try { fileContent = await file.text(); } catch (error) { statusDiv.innerHTML = `<p class="error">讀取檔案失敗：${error.message}</p>`; return; }
            let allStoryNames = []; const storySectionMatch = fileContent.match(/\$ STORIES - IN SEQUENCE FROM TOP([\s\S]*?)(?=\$|$)/i); if (storySectionMatch) { allStoryNames = storySectionMatch[1].trim().split('\n').map(line => line.match(/STORY\s+"([^"]+)"/i)?.[1]).filter(Boolean); }
            if (allStoryNames.length === 0) { statusDiv.innerHTML = '<p class="error">錯誤：找不到樓層定義 ($ STORIES)。</p>'; return; }
            
            try {
                statusDiv.innerHTML += `<p>找到 ${allStoryNames.length} 個樓層，正在解析梁元件...</p>`;
                const grids = parseGrids(fileContent); const joints = parseJoints(fileContent); 
                let allBeamsAcrossStories = [];
                for (const story of allStoryNames) { const frames = parseFrames(fileContent, story); if (frames.length > 0) allBeamsAcrossStories.push(...frames); }
                if (allBeamsAcrossStories.length === 0) throw new Error("在所有樓層中均未找到符合條件的梁。");
                
                statusDiv.innerHTML += `<p>共找到 ${allBeamsAcrossStories.length} 支梁，正在逐層進行編號...</p>`;
                const storyOrder = allStoryNames.reduce((acc, story, index) => { acc[story] = index; return acc; }, {});
                storyOrderInfo = storyOrder;

                let allLabeledBeams = [];
                for (const story of allStoryNames) {
                    const beamsInStory = allBeamsAcrossStories.filter(b => b.story === story);
                    if (beamsInStory.length === 0) continue;
                    
                    const labelComponentMap = generateLabelsForStory(beamsInStory, joints, grids);
                    
                    const labeledBeams = beamsInStory.map(beam => {
                        const components = labelComponentMap.get(beam.name); if (!components) { return { ...beam, newLabel: null }; }
                        let prefix = ''; const propUpper = beam.prop.toUpperCase();
                        if (components.isVertical) { prefix = propUpper.startsWith('FB') ? 'FB' : 'B'; } else { prefix = propUpper.startsWith('FB') ? 'FGB' : 'G'; }
                        const newLabel = `${prefix}${components.primaryGridName}${components.subGridMarker}-${components.serial}`; return { ...beam, newLabel: newLabel };
                    });
                    allLabeledBeams.push(...labeledBeams);
                }

                let finalProcessedData = applySpecialPrefixRules(allLabeledBeams);
                finalProcessedData = finalProcessedData.filter(beam => beam.newLabel);
                processedBeamsData = finalProcessedData;

                processedBeamsData.sort((a, b) => {
                    const storyCompare = storyOrder[a.story] - storyOrder[b.story];
                    if(storyCompare !== 0) return storyCompare;
                    return (a.newLabel || "").localeCompare(b.newLabel || "", undefined, { numeric: true });
                });
                
                allGrids = grids; // Store grids globally
                allBeamsData = allBeamsAcrossStories.map(f => ({ ...f, j1: joints[f.joint1], j2: joints[f.joint2] }));
                const labeledDrawableBeams = processedBeamsData.map(b => ({...b, j1: joints[b.joint1], j2: joints[b.joint2]}));

                // Populate floor dropdown
                const floorSelect = document.getElementById('floorSelect');
                floorSelect.innerHTML = '<option value="all">所有樓層</option>';
                allStoryNames.forEach(story => {
                    const option = document.createElement('option');
                    option.value = story;
                    option.textContent = story;
                    floorSelect.appendChild(option);
                });
                
                displayResults(labeledDrawableBeams, allBeamsData, svg, tableBody, allGrids, 'all');

                // Update table content for initial load
                tableBody.innerHTML = '';
                processedBeamsData.forEach(beam => {
                    const row = tableBody.insertRow();
                    row.insertCell(0).textContent = beam.story;
                    row.insertCell(1).textContent = beam.name;
                    row.insertCell(2).textContent = beam.newLabel;
                    row.insertCell(3).textContent = beam.prop;
                });

                statusDiv.innerHTML = `<p>處理完成！共 ${finalProcessedData.length} 筆資料已編號。</p>`;
                if (processedBeamsData.length > 0) { exportBtn.disabled = false; }
            } catch (error) { statusDiv.innerHTML = `<p class="error">處理失敗：${error.message}</p>`; console.error(error); }
        }
    </script>
</body>
</html>
