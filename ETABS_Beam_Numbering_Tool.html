<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ETABS 梁自動編號工具 (v30 - 最終架構修正)</title>
    <script src="https://cdn.sheetjs.com/xlsx-latest/package/dist/xlsx.full.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', 'Microsoft JhengHei', sans-serif;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
            background-color: #2c3e50;
            color: #ecf0f1;
        }
        h1 {
            color: #e67e22;
            text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
        }
        #container {
            width: 90%;
            max-width: 1200px;
            background: #34495e;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 5px 15px rgba(0,0,0,0.2);
            border: 1px solid #4a6278;
        }
        .controls {
            margin-bottom: 20px;
            padding: 20px;
            border: 1px dashed #4a6278;
            border-radius: 5px;
            display: flex;
            gap: 15px;
            align-items: center;
            flex-wrap: wrap;
        }
        input[type="file"] {
            border: 1px solid #7f8c8d;
            padding: 8px;
            border-radius: 4px;
            background-color: #2c3e50;
            color: #ecf0f1;
        }
        button {
            padding: 10px 20px;
            color: white;
            background-color: #e67e22;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 16px;
            transition: background-color 0.3s;
            text-shadow: 1px 1px 1px rgba(0,0,0,0.2);
        }
        button:hover {
            background-color: #d35400;
        }
        /* No need for separate button classes, all buttons are orange now */
        .btn-process, .btn-export {}
        .btn-process:hover, .btn-export:hover {}
        button:disabled {
            background-color: #7f8c8d;
            cursor: not-allowed;
            color: #bdc3c7;
        }
        #output {
            display: flex;
            gap: 20px;
            margin-top: 20px;
            flex-wrap: wrap;
        }
        #drawing, #results-table {
            flex: 1;
            min-width: 300px;
            border: 1px solid #4a6278;
            padding: 10px;
            border-radius: 5px;
            max-height: 70vh;
            overflow: auto;
            background-color: #2c3e50;
        }
        #drawing-svg {
            width: 100%;
            height: 400px;
            border: 1px solid #4a6278;
        }
        table {
            width: 100%;
            border-collapse: collapse;
        }
        th, td {
            border: 1px solid #4a6278;
            padding: 8px;
            text-align: left;
            word-break: break-all;
        }
        th {
            background-color: #4a6278;
        }
        .error {
            color: #e74c3c; /* A nicer red */
            font-weight: bold;
        }
    </style>
</head>
<body>
    <div id="container">
        <h1>ETABS 梁自動編號工具 (v30 - 最終架構修正)</h1>
        <div class="controls">
            <label for="e2kFile">請選擇 ETABS .e2k 檔案:</label>
            <input type="file" id="e2kFile" accept=".e2k">
            <button class="btn-process" onclick="processE2k()">開始編號</button>
            <button class="btn-export" id="exportBtn" onclick="exportToExcel()" disabled>匯出成 Excel</button>
        </div>
        <div id="status"></div>
        <div id="output">
            <div id="drawing">
                <h3>結構平面圖 (所有樓層合併)</h3>
                <svg id="drawing-svg"></svg>
            </div>
            <div id="results-table">
                <h3>編號對照表 (所有樓層)</h3>
                <table id="beam-table">
                    <thead>
                        <tr><th>樓層</th><th>原始 ETABS 編號</th><th>新編號</th><th>Property</th></tr>
                    </thead>
                    <tbody></tbody>
                </table>
            </div>
        </div>
    </div>
    <script>
        let processedBeamsData = [];
        let storyOrderInfo = {};
        const TOLERANCE = 0.1;

        function parseGrids(content) {
            const grids = { x: [], y: [] };
            const gridTableSection = content.match(/TABLE:\s+"GRID DEFINITIONS - LINES"([\s\S]*?)(?=TABLE:|$)/);
            if (gridTableSection) {
                let currentGrid = {};
                const lines = gridTableSection[1].trim().split('\n');
                lines.forEach(line => {
                    const trimmedLine = line.trim();
                    if (trimmedLine === "") {
                        if (currentGrid.name && currentGrid.type && currentGrid.ordinate !== undefined) {
                            if (currentGrid.type.toUpperCase() === 'X') grids.x.push(currentGrid); else if (currentGrid.type.toUpperCase() === 'Y') grids.y.push(currentGrid);
                        }
                        currentGrid = {};
                    } else {
                        const match = trimmedLine.match(/(\S+)\s*=\s*"?([^"]*)"?/);
                        if (match) { const [, key, value] = match; if (key === 'GridID') currentGrid.name = value; if (key === 'GridType') currentGrid.type = value; if (key === 'Ordinate') currentGrid.ordinate = parseFloat(value); }
                    }
                });
                if (currentGrid.name) { if (currentGrid.type.toUpperCase() === 'X') grids.x.push(currentGrid); else if (currentGrid.type.toUpperCase() === 'Y') grids.y.push(currentGrid); }
            }
            if (grids.x.length === 0 && grids.y.length === 0) {
                const gridDollarSection = content.match(/\$ GRIDS([\s\S]*?)(?=\$|$)/);
                if (gridDollarSection) {
                    const lines = gridDollarSection[1].trim().split('\n');
                    lines.forEach(line => {
                        const match = line.match(/LABEL\s+"([^"]+)"\s+DIR\s+"(X|Y)"\s+COORD\s+([-\d\.]+)/i);
                        if (match) { const [, name, type, ordinate] = match; const gridInfo = { name, type, ordinate: parseFloat(ordinate) }; if (type.toUpperCase() === 'X') grids.x.push(gridInfo); else if (type.toUpperCase() === 'Y') grids.y.push(gridInfo); }
                    });
                }
            }
            if (grids.x.length === 0 && grids.y.length === 0) { throw new Error("找不到格線定義。"); }
            grids.x = [...new Map(grids.x.map(item => [item.name, item])).values()].sort((a, b) => a.ordinate - b.ordinate);
            grids.y = [...new Map(grids.y.map(item => [item.name, item])).values()].sort((a, b) => a.ordinate - b.ordinate);
            return grids;
        }

        function parseJoints(content) {
            const joints = {};
            const jointTableSection = content.match(/TABLE:\s+"JOINT COORDINATES"([\s\S]*?)(?=TABLE:|$)/);
            if (jointTableSection) {
                const lines = jointTableSection[1].trim().split('\n');
                lines.forEach(line => { if (line.trim().startsWith('JOINT')) return; const match = line.trim().match(/^"([^"]+)"\s+([-\d\.]+)\s+([-\d\.]+)/); if (match) { joints[match[1]] = { x: parseFloat(match[2]), y: parseFloat(match[3]) }; } });
            }
            if (Object.keys(joints).length === 0) {
                const lines = content.split('\n');
                lines.forEach(line => { const match = line.trim().match(/^POINT\s+"([^"]+)"\s+([-\d\.]+)\s+([-\d\.]+)/); if (match) { joints[match[1]] = { x: parseFloat(match[2]), y: parseFloat(match[3]) }; } });
            }
            if (Object.keys(joints).length === 0) {
                const jointDollarSection = content.match(/\$ JOINTS([\s\S]*?)(?=\$|$)/s);
                if (jointDollarSection) {
                    const lines = jointDollarSection[1].trim().split('\n');
                    lines.forEach(line => { const match = line.match(/NAME\s*=\s*(\S+)\s*X\s*=\s*([-\d\.]+)\s*Y\s*=\s*([-\d\.]+)/); if (match) { joints[match[1]] = { x: parseFloat(match[2]), y: parseFloat(match[3]) }; } });
                }
            }
            if (Object.keys(joints).length === 0) { throw new Error("找不到節點座標定義。"); }
            return joints;
        }

        function parseFrames(content, story) {
            const frames = [];
            const isBeamProp = (propName) => {
                if (!propName) return false;
                const p = propName.toUpperCase();
                return (p.startsWith('B') && !p.startsWith('SB')) || p.startsWith('FB') || p.startsWith('WB') || p.startsWith('FWB') || /^\d+[B]/.test(p);
            };
            const frameTableSection = content.match(/TABLE:\s+"CONNECTIVITY - FRAME"([\s\S]*?)(?=TABLE:|$)/);
            const frameAssignSection = content.match(/TABLE:\s+"FRAME ASSIGNS - SECTION"([\s\S]*?)(?=TABLE:|$)/);
            if (frameTableSection && frameAssignSection) {
                const connectivityLines = frameTableSection[1].trim().split('\n'); const assignLines = frameAssignSection[1].trim().split('\n'); const frameProperties = new Map();
                assignLines.forEach(line => { const match = line.trim().match(/^"([^"]+)"\s+"([^"]+)"\s+"([^"]+)"/); if (match && match[2] === story) { frameProperties.set(match[1], match[3]); } });
                connectivityLines.forEach(line => { const match = line.trim().match(/^"([^"]+)"\s+"([^"]+)"\s+"([^"]+)"/); if (match) { const [, name, joint1, joint2] = match; const propName = frameProperties.get(name); if (isBeamProp(propName)) { frames.push({ name, prop: propName, joint1, joint2, story }); } } });
            }
            if (frames.length === 0) {
                const lineConnectivitySection = content.match(/\$ LINE CONNECTIVITIES([\s\S]*?)(?=\$|$)/i); const lineAssignsSection = content.match(/\$ LINE ASSIGNS([\s\S]*?)(?=\$|$)/i);
                if (lineConnectivitySection && lineAssignsSection) {
                    const connectLines = lineConnectivitySection[1].trim().split('\n'); const assignLines = lineAssignsSection[1].trim().split('\n'); const beamAssigns = new Map();
                    assignLines.forEach(line => { const assignMatch = line.match(new RegExp(`LINEASSIGN\\s+"([^"]+)"\\s+"${story}"\\s+SECTION\\s+"([^"]+)"`, 'i')); if (assignMatch) { const [, name, propName] = assignMatch; if (isBeamProp(propName)) { beamAssigns.set(name, propName); } } });
                    connectLines.forEach(line => { const connMatch = line.match(/LINE\s+"([^"]+)"\s+BEAM\s+"([^"]+)"\s+"([^"]+)"/i); if (connMatch) { const [, name, joint1, joint2] = connMatch; if (beamAssigns.has(name)) { frames.push({ name, prop: beamAssigns.get(name), joint1, joint2, story }); } } });
                }
            }
            return frames;
        }

        function findClosestGrid(coordinate, grids) {
            if (!grids || grids.length === 0) return null;
            return grids.reduce((closest, current) => {
                const closestDiff = Math.abs(coordinate - closest.ordinate);
                const currentDiff = Math.abs(coordinate - current.ordinate);
                return currentDiff < closestDiff ? current : closest;
            });
        }
        
        function generateLabelsForStory(beamsInStory, joints, grids) {
            const labelComponentMap = new Map();
            const beamsWithCoords = beamsInStory.map(b => {
                const j1 = joints[b.joint1]; const j2 = joints[b.joint2]; if (!j1 || !j2) return null;
                return { ...b, j1, j2,
                    centerX: (j1.x + j2.x) / 2, centerY: (j1.y + j2.y) / 2,
                    minX: Math.min(j1.x, j2.x), maxX: Math.max(j1.x, j2.x),
                    minY: Math.min(j1.y, j2.y), maxY: Math.max(j1.y, j2.y),
                    isHorizontal: Math.abs(j1.y - j2.y) < TOLERANCE, isVertical: Math.abs(j1.x - j2.x) < TOLERANCE
                };
            }).filter(Boolean);

            const yGridNameToNum = new Map(grids.y.map((grid, index) => [grid.name, index + 1]));

            // --- 1. 處理水平梁 ---
            const horizontalBeams = beamsWithCoords.filter(b => b.isHorizontal);
            const onGridHorizontal = []; const offGridHorizontal = [];
            horizontalBeams.forEach(beam => {
                let onGrid = false;
                for (const grid of grids.y) { if (Math.abs(beam.centerY - grid.ordinate) < TOLERANCE) { onGrid = true; break; } }
                if (onGrid) { onGridHorizontal.push(beam); } else { offGridHorizontal.push(beam); }
            });

            onGridHorizontal.forEach(beam => {
                const onGrid = findClosestGrid(beam.centerY, grids.y);
                const endGrid = findClosestGrid(beam.maxX, grids.x);
                if (onGrid && endGrid) {
                    const serial = parseInt(endGrid.name, 10);
                    if(!isNaN(serial)) {
                        labelComponentMap.set(beam.name, { isVertical: false, primaryGridName: onGrid.name, subGridMarker: '', serial: serial });
                    }
                }
            });

            const yBayGroups = new Map();
            offGridHorizontal.forEach(beam => {
                let prevGrid = null, nextGrid = null;
                for (let i = 0; i < grids.y.length - 1; i++) {
                    if (beam.centerY > grids.y[i].ordinate && beam.centerY < grids.y[i+1].ordinate) {
                        prevGrid = grids.y[i]; nextGrid = grids.y[i+1]; break;
                    }
                }
                if (prevGrid && nextGrid) { const bayKey = `${prevGrid.name}_${nextGrid.name}`; if (!yBayGroups.has(bayKey)) yBayGroups.set(bayKey, []); yBayGroups.get(bayKey).push(beam); }
            });
            yBayGroups.forEach((beamsInBay, bayKey) => {
                const prevYGridName = bayKey.split('_')[0];
                const uniqueYCoords = [...new Set(beamsInBay.map(b => b.centerY.toFixed(2)))].sort((a,b) => parseFloat(a) - parseFloat(b));
                const yCoordToRank = new Map(uniqueYCoords.map((coord, index) => [coord, index]));
                beamsInBay.forEach(beam => {
                    const endGrid = findClosestGrid(beam.maxX, grids.x);
                    if (endGrid) {
                        const rank = yCoordToRank.get(beam.centerY.toFixed(2));
                        const serial = parseInt(endGrid.name, 10);
                        if (!isNaN(serial) && rank !== undefined) {
                            const subGridMarker = "'".repeat(rank + 1);
                            labelComponentMap.set(beam.name, { isVertical: false, primaryGridName: prevYGridName, subGridMarker: subGridMarker, serial: serial });
                        }
                    }
                });
            });

            // --- 2. 處理垂直梁 ---
            const verticalBeams = beamsWithCoords.filter(b => b.isVertical);
            const onGridVertical = []; const offGridVertical = [];
            verticalBeams.forEach(beam => {
                let onGrid = false;
                for (const grid of grids.x) { if (Math.abs(beam.centerX - grid.ordinate) < TOLERANCE) { onGrid = true; break; } }
                if (onGrid) { onGridVertical.push(beam); } else { offGridVertical.push(beam); }
            });

            onGridVertical.forEach(beam => {
                const onGrid = findClosestGrid(beam.centerX, grids.x);
                const endGrid = findClosestGrid(beam.maxY, grids.y);
                if (onGrid && endGrid) {
                    const endYGridNum = yGridNameToNum.get(endGrid.name);
                    if (endYGridNum !== undefined) {
                        const serial = endYGridNum - 1;
                        labelComponentMap.set(beam.name, { isVertical: true, primaryGridName: onGrid.name, subGridMarker: '', serial: serial });
                    }
                }
            });

            const xBayGroups = new Map();
            offGridVertical.forEach(beam => {
                let prevGrid = null, nextGrid = null;
                for (let i = 0; i < grids.x.length - 1; i++) { if (beam.centerX > grids.x[i].ordinate && beam.centerX < grids.x[i+1].ordinate) { prevGrid = grids.x[i]; nextGrid = grids.x[i+1]; break; } }
                if (prevGrid && nextGrid) { const bayKey = `${prevGrid.name}_${nextGrid.name}`; if (!xBayGroups.has(bayKey)) xBayGroups.set(bayKey, []); xBayGroups.get(bayKey).push(beam); }
            });
            xBayGroups.forEach((group, bayKey) => {
                const prevXGridName = bayKey.split('_')[0];
                const uniqueXCoords = [...new Set(group.map(b => b.centerX.toFixed(2)))].sort((a, b) => parseFloat(a) - parseFloat(b));
                const xCoordToRank = new Map(uniqueXCoords.map((coord, index) => [coord, index]));
                group.forEach(beam => {
                    const endGrid = findClosestGrid(beam.maxY, grids.y);
                    if (endGrid) {
                        const rank = xCoordToRank.get(beam.centerX.toFixed(2));
                        const endYGridNum = yGridNameToNum.get(endGrid.name);
                        if (endYGridNum !== undefined && rank !== undefined) {
                            const serial = endYGridNum - 1;
                            const subGridMarker = "'".repeat(rank + 1);
                            labelComponentMap.set(beam.name, { isVertical: true, primaryGridName: prevXGridName, subGridMarker: subGridMarker, serial: serial });
                        }
                    }
                });
            });
            return labelComponentMap;
        }

        function applySpecialPrefixRules(allBeams) {
            const processPrefix = (prefix) => {
                const targetBeams = allBeams.filter(b => b.prop && b.prop.toUpperCase().startsWith(prefix)); if (targetBeams.length === 0) return null;
                const uniqueProps = [...new Set(targetBeams.map(b => b.prop))];
                const propRanks = uniqueProps.map(prop => { const match = prop.match(/(\d+)[xX](\d+)/); if (match) { return { propName: prop, area: parseInt(match[1], 10) * parseInt(match[2], 10) }; } return { propName: prop, area: Infinity }; }).sort((a, b) => a.area - b.area);
                const propToLabelMap = new Map(); propRanks.forEach((propInfo, index) => { propToLabelMap.set(propInfo.propName, `${prefix}${index + 1}`); }); return propToLabelMap;
            };
            const wbLabelMap = processPrefix('WB'); const fwbLabelMap = processPrefix('FWB');
            return allBeams.map(beam => {
                if (wbLabelMap && wbLabelMap.has(beam.prop)) { return { ...beam, newLabel: wbLabelMap.get(beam.prop) }; }
                if (fwbLabelMap && fwbLabelMap.has(beam.prop)) { return { ...beam, newLabel: fwbLabelMap.get(beam.prop) }; }
                return beam;
            });
        }

        function displayResults(labeledBeams, allBeams, svg, tableBody) {
            tableBody.innerHTML = ''; labeledBeams.forEach(beam => { const row = tableBody.insertRow(); row.insertCell(0).textContent = beam.story; row.insertCell(1).textContent = beam.name; row.insertCell(2).textContent = beam.newLabel; row.insertCell(3).textContent = beam.prop; });
            const allCoords = allBeams.flatMap(b => [b.j1, b.j2]).filter(Boolean); if (allCoords.length === 0) { svg.innerHTML = '<text x="50%" y="50%" fill="#ecf0f1" text-anchor="middle">無資料</text>'; return; }
            const minX = Math.min(...allCoords.map(p => p.x)), maxX = Math.max(...allCoords.map(p => p.x)); const minY = Math.min(...allCoords.map(p => p.y)), maxY = Math.max(...allCoords.map(p => p.y));
            const padding = 50, svgWidth = svg.clientWidth, svgHeight = svg.clientHeight; const contentWidth = maxX - minX, contentHeight = maxY - minY; let scale = Math.min((svgWidth - 2 * padding) / (contentWidth||1), (svgHeight - 2 * padding) / (contentHeight||1)) * 0.9;
            if (!isFinite(scale) || scale === 0) scale = 1;
            const transformX = (x) => padding + (x - minX) * scale; const transformY = (y) => svgHeight - padding - (y - minY) * scale;
            svg.innerHTML = '';
            const allDrawableBeams = allBeams.filter(b => b.j1 && b.j2);
            allDrawableBeams.forEach(beam => {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', transformX(beam.j1.x)); line.setAttribute('y1', transformY(beam.j1.y));
                line.setAttribute('x2', transformX(beam.j2.x)); line.setAttribute('y2', transformY(beam.j2.y));
                line.setAttribute('stroke', '#7f8c8d'); line.setAttribute('stroke-width', '1'); svg.appendChild(line);
            });
            const labeledDrawableBeams = labeledBeams.filter(b => b.j1 && b.j2);
            labeledDrawableBeams.forEach(beam => {
                const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                line.setAttribute('x1', transformX(beam.j1.x)); line.setAttribute('y1', transformY(beam.j1.y));
                line.setAttribute('x2', transformX(beam.j2.x)); line.setAttribute('y2', transformY(beam.j2.y));
                const isSpecial = beam.newLabel && (beam.newLabel.startsWith('WB') || beam.newLabel.startsWith('FWB'));
                line.setAttribute('stroke', isSpecial ? '#f39c12' : '#e67e22'); line.setAttribute('stroke-width', '3'); svg.appendChild(line);
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text'); const textX = (transformX(beam.j1.x) + transformX(beam.j2.x)) / 2; const textY = (transformY(beam.j1.y) + transformY(beam.j2.y)) / 2 - 5;
                text.setAttribute('x', textX); text.setAttribute('y', textY); text.setAttribute('fill', '#ecf0f1'); text.setAttribute('font-size', '10'); text.setAttribute('text-anchor', 'middle'); text.textContent = beam.newLabel; svg.appendChild(text);
            });
        }
        
        function exportToExcel() {
            if (processedBeamsData.length === 0) { alert("沒有資料可以匯出。"); return; }
            const dataForExport = [...processedBeamsData]; if (Object.keys(storyOrderInfo).length > 0) { dataForExport.sort((a, b) => storyOrderInfo[a.story] - storyOrderInfo[b.story]); }
            const worksheetData = dataForExport.map(beam => ({ '樓層': beam.story, '原始ETABS編號': beam.name, '新編號': beam.newLabel, 'Property': beam.prop }));
            const worksheet = XLSX.utils.json_to_sheet(worksheetData); const workbook = XLSX.utils.book_new(); XLSX.utils.book_append_sheet(workbook, worksheet, "梁編號對照表"); XLSX.writeFile(workbook, "ETABS_Beam_Numbering.xlsx");
        }
        
        async function processE2k() {
            const fileInput = document.getElementById('e2kFile'); const statusDiv = document.getElementById('status'); const svg = document.getElementById('drawing-svg'); const tableBody = document.querySelector("#beam-table tbody"); const exportBtn = document.getElementById('exportBtn');
            statusDiv.innerHTML = ''; svg.innerHTML = ''; tableBody.innerHTML = ''; processedBeamsData = []; storyOrderInfo = {}; exportBtn.disabled = true;
            if (fileInput.files.length === 0) { statusDiv.innerHTML = '<p class="error">錯誤：請先選擇一個 .e2k 檔案。</p>'; return; }
            const file = fileInput.files[0]; statusDiv.innerHTML = `<p>正在讀取檔案 "${file.name}"...</p>`; let fileContent; try { fileContent = await file.text(); } catch (error) { statusDiv.innerHTML = `<p class="error">讀取檔案失敗：${error.message}</p>`; return; }
            let allStoryNames = []; const storySectionMatch = fileContent.match(/\$ STORIES - IN SEQUENCE FROM TOP([\s\S]*?)(?=\$|$)/i); if (storySectionMatch) { allStoryNames = storySectionMatch[1].trim().split('\n').map(line => line.match(/STORY\s+"([^"]+)"/i)?.[1]).filter(Boolean); }
            if (allStoryNames.length === 0) { statusDiv.innerHTML = '<p class="error">錯誤：找不到樓層定義 ($ STORIES)。</p>'; return; }
            
            try {
                statusDiv.innerHTML += `<p>找到 ${allStoryNames.length} 個樓層，正在解析梁元件...</p>`;
                const grids = parseGrids(fileContent); const joints = parseJoints(fileContent); 
                let allBeamsAcrossStories = [];
                for (const story of allStoryNames) { const frames = parseFrames(fileContent, story); if (frames.length > 0) allBeamsAcrossStories.push(...frames); }
                if (allBeamsAcrossStories.length === 0) throw new Error("在所有樓層中均未找到符合條件的梁。");
                
                statusDiv.innerHTML += `<p>共找到 ${allBeamsAcrossStories.length} 支梁，正在逐層進行編號...</p>`;
                const storyOrder = allStoryNames.reduce((acc, story, index) => { acc[story] = index; return acc; }, {});
                storyOrderInfo = storyOrder;

                let allLabeledBeams = [];
                for (const story of allStoryNames) {
                    const beamsInStory = allBeamsAcrossStories.filter(b => b.story === story);
                    if (beamsInStory.length === 0) continue;
                    
                    const labelComponentMap = generateLabelsForStory(beamsInStory, joints, grids);
                    
                    const labeledBeams = beamsInStory.map(beam => {
                        const components = labelComponentMap.get(beam.name); if (!components) { return { ...beam, newLabel: null }; }
                        let prefix = ''; const propUpper = beam.prop.toUpperCase();
                        if (components.isVertical) { prefix = propUpper.startsWith('FB') ? 'FB' : 'B'; } else { prefix = propUpper.startsWith('FB') ? 'FGB' : 'G'; }
                        const newLabel = `${prefix}${components.primaryGridName}${components.subGridMarker}-${components.serial}`; return { ...beam, newLabel: newLabel };
                    });
                    allLabeledBeams.push(...labeledBeams);
                }

                let finalProcessedData = applySpecialPrefixRules(allLabeledBeams);
                finalProcessedData = finalProcessedData.filter(beam => beam.newLabel);
                processedBeamsData = finalProcessedData;

                processedBeamsData.sort((a, b) => {
                    const storyCompare = storyOrder[a.story] - storyOrder[b.story];
                    if(storyCompare !== 0) return storyCompare;
                    return (a.newLabel || "").localeCompare(b.newLabel || "", undefined, { numeric: true });
                });
                
                const allDrawableBeams = allBeamsAcrossStories.map(f => ({ ...f, j1: joints[f.joint1], j2: joints[f.joint2] }));
                const labeledDrawableBeams = processedBeamsData.map(b => ({...b, j1: joints[b.joint1], j2: joints[b.joint2]}));
                
                displayResults(labeledDrawableBeams, allDrawableBeams, svg, tableBody);
                statusDiv.innerHTML = `<p>處理完成！共 ${finalProcessedData.length} 筆資料已編號。</p>`;
                if (processedBeamsData.length > 0) { exportBtn.disabled = false; }
            } catch (error) { statusDiv.innerHTML = `<p class="error">處理失敗：${error.message}</p>`; console.error(error); }
        }
    </script>
</body>
</html>